<!-- Author: Viktoriia Vovchenko -->

<!-- Dunklen Hintergrund anzeigen falls größe Ansicht geöffnet -->
<div *ngIf="wideOpen" class="background" (click)="wideOpen = false;"></div>

<div id="container" [ngClass]="{'wide-open': wideOpen}" [ngStyle]="{'--border-color': themeColors[theme]['border-color'], '--text-color': themeColors[theme].text, '--main-background': themeColors[theme].background, '--table-header': themeColors[theme]['table-header'], '--second-background': themeColors[theme]['second-background']}">

  <!-- Name und action-Butons anzeigen -->
  <div id="top-elements-container">
    <p *ngIf="name != ''" class="name">{{ name }}</p>
    <div id="table-actions">
      <button *ngIf="aenderungenLoeschenAngezeigt()" (click)="aenderungenLoeschen()">Änderungen löschen</button>

      <div *ngIf="!wideOpen" (click)="wideOpen = true;" class="img">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256" width="256" height="256">
          <path fill="none" d="M0 0h256v256H0z"></path>
          <path [attr.stroke]="themeColors[theme].text" stroke-linecap="round" stroke-linejoin="round" stroke-width="10"
                d="M168 48h40v40M152 104l56-56M88 208H48v-40M104 152l-56 56M208 168v40h-40M152 152l56 56M48 88V48h40M104 104 48 48"></path>
        </svg>
      </div>

      <div *ngIf="wideOpen" (click)="wideOpen = false;" class="img">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 256" width="256" height="256">
          <path fill="none" d="M0 0h256v256H0z"></path>
          <path [attr.stroke]="themeColors[theme].text" stroke-linecap="round" stroke-linejoin="round" stroke-width="10"
                d="M192 104h-40V64M208 48l-56 56M64 152h40v40M48 208l56-56M152 192v-40h40M208 208l-56-56M104 64v40H64M48 48l56 56"></path>
        </svg>
      </div>

    </div>
  </div>

  <!-- Tabelle dynamisch generieren -->
  <div id="table-container">
    <div *ngIf="tableDataFormatted.length > 0" id="table-content-container">
      <table #table>

        <!-- Header mithilfe von Variable tableHeaderFormatted generieren -->
        <thead>
          <tr>
            <th *ngFor="let data of tableHeaderFormatted" class="outline-top-bottom">
              <div class="header-content">
                <div>{{ data.wert }}</div>
                <div #icon (click)="showFilterSortPopup(data, icon)" alt="icon" class="img">

                  <svg viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" xmlns:bx="https://boxy-svg.com">
                    <defs/>
                    <!-- Base Icon - arrow down to show filter-sort popup -->
                    <g [attr.fill]="themeColors[theme].text" class="fill-121313" transform="matrix(0.478275, 0, 0, 0.478275, 8.245858, 8.658251)">
                      <path d="M30 0H2a2 2 0 0 0-2 2v28a2 2 0 0 0 2 2h28a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2zm0 30H2V2h28v28z"/>
                      <path clip-rule="evenodd" d="M27 12.106c0-.564-.489-1.01-1.044-.995H6.013c-.887-.024-1.38 1.07-.742 1.702l9.999 9.9c.394.39 1.031.376 1.429 0l9.991-9.892a.988.988 0 0 0 .31-.715zm-11.016 8.485L8.418 13.1H23.55l-7.566 7.491z" fill-rule="evenodd"/>
                    </g>

                    <!-- Sorting is selected - draw triangle -->
                    <path *ngIf="getArrowSrc(data) == 'arrowWithSort'" [attr.stroke]="themeColors[theme].text" d="M 26.538 -7.093 Q 27.182 -8.098 27.81 -7.093 L 30.918 -2.127 Q 31.546 -1.122 30.274 -1.122 L 23.984 -1.122 Q 22.712 -1.122 23.356 -2.127 Z" style="stroke-dashoffset: -1.5px; stroke-miterlimit: 18.05; stroke-linejoin: round; fill-rule: nonzero; fill: rgba(219, 209, 209, 0);" transform="matrix(1, 0, 0, -1, 0, 0)" bx:shape="triangle 22.712 -8.098 8.834 6.976 0.506 0.144 1@928e8a8f"/>

                    <!-- Filter is selected - draw circle -->
                    <ellipse *ngIf="getArrowSrc(data) == 'arrowWithPoint'" [attr.stroke]="themeColors[theme].text" style="fill: rgba(216, 216, 216, 0);" cx="27.34" cy="4.196" rx="3.217" ry="3.217"/>

                    <!-- Filter and Sorting is selected - draw both -->
                    <path *ngIf="getArrowSrc(data) == 'arrowWithPointAndSort'" [attr.stroke]="themeColors[theme].text" d="M 27.238 -5.933 Q 27.702 -6.656 28.154 -5.933 L 30.391 -2.357 Q 30.843 -1.634 29.927 -1.634 L 25.4 -1.634 Q 24.484 -1.634 24.947 -2.357 Z" style="stroke-dashoffset: -1.5px; stroke-miterlimit: 18.05; stroke-linejoin: round; fill-rule: nonzero; fill: rgba(219, 209, 209, 0);" transform="matrix(1, 0, 0, -1, 0, 0)" bx:shape="triangle 24.484 -6.656 6.359 5.022 0.506 0.144 1@0904c21f"/>
                    <ellipse *ngIf="getArrowSrc(data) == 'arrowWithPointAndSort'" [attr.stroke]="themeColors[theme].text" style="fill: rgba(216, 216, 216, 0);" cx="21.021" cy="4.049" rx="2.528" ry="2.528"/>
                  </svg>
                </div>
              </div>
            </th>
          </tr>
        </thead>

        <!-- Tabellenkontent mithilfe von Variable tableDataFormatted generieren -->
        <tbody>
          <ng-container *ngFor="let data of tableDataFormatted">
            <tr *ngIf="data.shown"> <!-- Nicht anzeigen falls durch den Filter ausgebledet -->
              <td *ngFor="let item of data.row">
                <div *ngIf="item.highlightedRange && filterSortPopup != null">
                  <!-- So eine Struktur mit span's wird für die Markierung bei der Anwendung vom Text-Filter benötigt -->
                  <span class="table-text">{{ item.wert.substring(0, item.highlightedRange.start) }}</span>
                  <span>
                    <mark>{{ item.wert.substring(item.highlightedRange.start, item.highlightedRange.end)}}</mark>
                  </span>
                  <span class="table-text">{{ item.wert.substring(item.highlightedRange.end, item.wert.length) }}</span>
                </div>
                <!-- Keine Markierung wegen Textfilter benötigt -->
                <div *ngIf="!item.highlightedRange || filterSortPopup == null" class="table-text">
                  {{ item.wert }}
                </div>
              </td>
            </tr>
          </ng-container>
        </tbody>

      </table>
    </div>

    <!-- Fehlermeldung anzeigen falls keine Daten vorhanden sind -->
    <div *ngIf="tableDataFormatted.length == 0" id="leer-fehlermeldung">
      <p class="grey-text">{{leerFehlermeldung}}</p>
    </div>
  </div>
</div>

<!-- Popup für Filter und Sortierung -->
<div #popup *ngIf="filterSortPopup != null" class="filter-sort-popup" [ngStyle]="popupPosition">
  <div class="popup-content">
    <!-- Sortierungen werden dynamisch aus getFilterSortPopupOptions().sortings generiert -->
    <div
      *ngFor="let sorting of getFilterSortPopupOptions().sortings"
      class="option global-button"
      (click)="toggleSorting(sorting, getFilterSortPopupOptions())"
      [ngClass]="{ selected: sorting.selected }"
    >
      <img [src]="sorting.imagesrc" alt="icon" />
      <div class="grey-text">{{ sorting.name }}</div>
    </div>

    <!-- Filter werden dynamisch aus getFilterSortPopupOptions().filters generiert -->
    <div *ngFor="let filterOption of getFilterSortPopupOptions().filters">

      <!-- Dropdown Filter, u. a. für das Datumfilter benutzt -->
      <div *ngIf="filterOption.typ === 'Dropdown'" class="filter dropdown-filter">
        <label class="grey-text">{{ filterOption.name }}</label>
        <app-custom-dropdown [options]="filterOption.optionen" [selectedOption]="selectedDropdownOption" (selectionChange)="filterOption.selected = $event; filterSelected()"></app-custom-dropdown>
      </div>

      <!-- Text Filter, u. a. für Namen benutzt -->
      <div *ngIf="filterOption.typ === 'Textfeld'" class="filter">
        <label class="grey-text">{{ filterOption.name }}</label>
        <input class="grey-text textfield"
          type="text"
          [(ngModel)]="filterOption.selected"
          (ngModelChange)="filterSelected()"
        />
      </div>

      <!-- Reichweitenfilter, u. a. für Preise und Werte benutzt -->
      <div *ngIf="filterOption.typ === 'Slider'" class="filter slider-filter">
        <label class="grey-text">{{ filterOption.name }}</label>
        <app-range-slider
          [min]="filterOption.min"
          [max]="filterOption.max"
          [step]="1"
          [(value1)]="filterOption.value1"
          [(value2)]="filterOption.value2"
          (value1Change)="filterSelected()"
          (value2Change)="filterSelected()"
        ></app-range-slider>
      </div>

      <!-- Checkbox Filter, u. a. für Wertpapiertypen benutzt -->
      <div *ngIf="filterOption.typ === 'Checkbox'" class="filter checkbox-filter">
        <label class="grey-text">{{ filterOption.name }}</label>
        <div *ngFor="let option of filterOption.optionen" class="checkbox-option">
          <input
            type="checkbox"
            [checked]="option.selected"
            (change)="option.selected = !option.selected; filterSelected()"
            class="custom-checkbox"
            id="{{option.name}}"
          />
          <label class="grey-text" for="{{option.name}}">{{ option.name }}</label>
        </div>
      </div>

    </div>
  </div>
</div>
